
Ex00 : static cast

Static cast : conversion entre des types compatibles et sans perte d'informations : int vers double par ex(type numerique)
, conversion de pointeurs de donnees compatibles ou references de type compatible...
Utilise pour des conversions connues a la compilation : si la conversion n'est pas compatible, il ya aura une erreurs
ou msg du compilateur. mais pas de verification dynamique a l'execution (comme le dynamic cast, cf plus bas)

Ex01 : reinterpret cast

Reinterpret cast : conversion forcee mais non sure. Permet de convertir un type de donnees
en autre type de donnees, force la conversion entre 2 types sans verifier la compatibilite. 
exemple : conversion d'un pointeur void* pointant vers un int en un pointeur int *
Dans quel cas peut on se retrouver a utiliser le reinterpret cast :
- utilisation avec des bibliotheques tierces (prototypes definies)


Ex02 : dynamic cast

Dynamic cast : utilisation avec des classes polymorphiques
et heritees. Utile pour convertir un pointeur ou une reference de la classe de BASE
en un pointeur ou reference de la classe derivee.
Si la conversion n'est pas possible, le "dynamic_cast" renverra un pointeur nul
pour les pointeurs ou lèvera une exception "std::bad_cast" pour les références (! penser au try and catch dans le cas des references !)
Cela permet d'éviter les erreurs de conversion potentielles à l'exécution.

